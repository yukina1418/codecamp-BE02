/* 

    Hash Table 은 어떠한 데이터를 저장할 때
    key 와 value 값을 가진 형태로 데이터를 저장하는 자료구조 입니다.

    만약, 어떤 데이터에 유저 정보를 담는 배열이 있다고 했을 때
    해당 유저의 정보를 찾으려면 앞에서부터 데이터를 찾아야 합니다.
    그런데 만약, 배열의 크기가 엄청 크다고 가정한다면
    반복하는 횟수 또한 그만큼 증가하게 됩니다.

    이렇게 일일히 데이터를 하나씩 검증하는 방식을
    선형 탐색이라고 합니다.

    이러한 비효율성을 개선하기 위해서 Hash Table 은
    특정 Key 값을 어떠한 특수한 값으로 해싱(Hashing)하여
    선형 탐색 방식을 사용하지 않고도 매우 빠르게
    데이터를 가져올 수 있습니다.

    해싱은 주어진 데이터를 암호화한 데이터로 변경하는 방식입니다.
    예를 들어, "a" 라는 문자열을 받았을 때
    이 문자열을 암호화하는 특수한 로직을 적용하면
    "fsd12dfwer" 라는 문자열로 바꿔줄 수 있습니다.

    이렇게 해싱을 처리해주는 함수를
    해시 함수라고도 합니다.

    예를 들어볼까요?
    "Junny" 라는 이름을 가지는 유저가 있다고 했을 때
    이 유저의 정보를 배열에 담아 저장하려고 합니다.

    이때, "Junny" 라는 문자열을 해싱하는 과정을 거쳤을 때
    15 라는 숫자를 받아오게 되고, 배열의 15 라는 인덱스 값으로
    직접 "Junny" 라는 데이터를 저장할 수 있습니다.

    그러면, 다음부터 "Junny" 라는 문자열을 받아오게 될 때마다
    해싱된 숫자 번호로 인덱스에 접근해주면 해당 배열의 데이터 값을 받아올 수 있습니다.

    Hash Table 을 사용하실 때 주의하실 점은
    해싱된 데이터가 중복될 경우 기존에 있던 데이터를 보존하는 처리가 필요하며
    인덱스에 따라 배열의 데이터가 할당되기 때문에 그만큼 배열의 크기가 커지게 되면서
    메모리의 소비가 늘어날 수 있으므로 배열의 크기가 커지는 것을 방지해야 합니다.

    또한, 해싱된 숫자 번호가 겹치게 되는 상황에서
    동일한 번호에 또 다른 데이터가 들어올 수도 있게 됩니다.
    이러한 상황을 '충돌' 이라고 합니다.

    Hash Table 에서는 이러한 충돌 상황을 최소화해야만 안정적인 데이터 저장이 가능합니다.
    보통은 해시함수를 2중으로 사용하여 번호의 범위를 최대화 하거나
    Linked List 를 이용하여 여러개의 데이터를 저장하는 방식을 사용할 수 있습니다.

*/