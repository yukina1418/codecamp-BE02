/* 

    stack 은 후입선출 특성을 가지는 자료구조 입니다.
    제일 나중에 들어온 데이터가 먼저 나가며
    제일 먼저 들어온 데이터는 제일 마지막에 나가는 구조를 가집니다.

    예시를 들어보자면, 바닥이 뚫려있지 않은 바구니에 책을 차례로 쌓았을 때
    제일 밑에 있는 책을 꺼내기 위해서 위에 있는 책들을 하나씩 꺼내면
    제일 밑에 있는 책은 가장 마지막에 꺼내게 됩니다.

    ----

    문제
    
    stack 함수는 숫자 데이터가 담겨있는 배열 arr 와
    배열에서 찾을 숫자를 나타내는 target 매개변수가 주어집니다.

    배열 안에서 찾을 숫자를 뒤에서부터 찾는다고 했을 때
    해당 숫자가 나오기 전까지의 모든 숫자들을 원본 배열에서 제거하고,
    제거된 숫자들을 새로운 배열에 차례로 담은 후 마지막 숫자를 새로운 배열 끝에 담아
    [ [제거된 원본 배열], [새로운 배열] ] 형태로 리턴해주세요.

    
    예를 들어, arr 데이터로 [1, 2, 3] 을 받고, target 으로 1 을 받았을 때
    배열에서 1 이전까지의 데이터인 3, 2 숫자 데이터를 차례로 새로운 배열에 담고
    마지막으로 찾은 target 숫자 데이터인 1 을 배열의 가장 마지막에 넣으면
    [3, 2, 1] 형태의 배열을 가질 수 있게 됩니다.

    이때 리턴값으로, 숫자 전까지 삭제된 원본 배열과 새로운 배열을 2차원 배열 형태로 리턴해야 하므로
    [ [], [3, 2, 1] ] 형태로 리턴합니다.
    만약, 배열에 해당 숫자가 없다면 새로운 배열은 빈 배열을 리턴해주세요.


    !! 배열의 맨 뒤의 데이터를 조회, 삭제하거나 추가하는 방법에 대해 고민해보세요.

    ----

    입력 예시

    1. stack([1, 2, 3, 4, 5], 3)

    2. stack([1, 2, 3, 4, 5], 6)

    3. stack([1, 2, 3, 4, 5], 2)

    4. stack([1, 2, 3, 4, 5], 1)

    
    ----

    출력 예시

    1.  [ [1, 2], [5, 4, 3] ]
    
    2.  [ [1, 2, 3, 4, 5], [] ]

    3.  [ [1], [5, 4, 3, 2] ]

    4.  [ [], [5, 4, 3, 2, 1] ]
    
*/

function stack(arr, target) {
  // 여기에 코드를 작성하세요.
  const arr1 = [];
  const arr2 = [];

  while (arr.length >= target) {
    arr1.push(arr.pop());
    console.log(arr.length);
  }
  arr2.push(arr, arr1);
  return arr2;
}

module.exports = stack;
